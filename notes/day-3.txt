Services
-------------------
contain reusable piece of logic

data access logic
business logic
sending HTTP request to RESTful API server application
storage and state management of data
etc.

IoC => Inversion of Control
IoC Container => to store the instances of the dependency factor (service)

providers => 
[
	{
		provide(token): DataService
		useClass: DataService
	}
]
equivalent to [DataService]
register this provider ????

custom provider registration:
----------------------------------
use a token name different than the class name itself using "provide" property and use "useClass" property to mention the class name

@Inject(<token-name>) decorator:
-----------------------------------------
used with the parameter/argument of the constructor, NOT with anything else.

In Angular every asset (component, service, directive, module, pipe) MUST be decorated with @Injectable() if you want DI of that asset

Injectable
	- Component
	- Directive
	- Pipe
	- NgModule

best practice (*Not mandatory) in case a service itself has internal dependency that Angular needs to resolve and also for uniformity

If you are registering a service with default technique (providers:[ServiceName]) and using an interface for a service and while mentioning DI, use the interface as the data type of the constructor argument, Angular will throw compilation error (it will look for a token by the name of the interface) since interface name can't be used as token (since interface is exclusive feature of TS, not JS and when this TS code is transpiled into JS, interface code will not be transpiled, so there will be no token in JS code)


data fetching from RESTful API server
sending request via web socket
reading data from file

JS is single threaded and also JS does not have multi threading facility

asynchronous

synchronous
main(){
	add(12,13)
	subtract(12,3)
}

Threading => Thread 
Tasks


component lifecycle:
-------------------------------
x	=> OnX	     => ngOnX
--------------------------------------
changes	=> OnChanges => ngOnChanges(){}
init	=> OnInit    => ngOnInit()
destroy	=> OnDestroy => ngOnDestroy

ngOnChanges:
--------------------
A callback method that is invoked immediately after the default change detector has checked data-bound properties if at least one has changed, and before the view and content children are checked.
note: this callback will be executed time and again the any of the data-bound properties of the child gets updated input
good for: doing some operation based on fresh input every time,  such as fetching data every time from RESTful backend server based on new input from parent

ngOnInit:
------------------
A callback method that is invoked immediately after the default change detector has checked the directive's data-bound properties "for the first time", and before any of the view or content children have been checked. 
note: It is invoked only once when the directive/component is instantiated.
good for: doing some operation which needs to be done ONLY one time, such as fetching data only one time from RESTful backend server